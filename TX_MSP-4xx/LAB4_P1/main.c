/* Description: Pressing BUTTON1 toggles RED LED and pressing BUTTON2
 * the GREEN LED. Implemented using interrupts.
 * Adapted from code listing 6.10 (p. 100) from the textbook.
 *
 * Author: Giri Prabhu
 * Modified: Naga Kandasamy, July 16, 2019
*******************************************************************************/

/* DriverLib includes. */
#include <ti/devices/msp432p4xx/driverlib/driverlib.h>

/* Standard includes. */
#include <stdint.h>
#include <stdbool.h>

#define FALSE 0
#define TRUE 1
#define SWITCH_PRESSED 2
#define SWITCH_RELEASED 3
#define DELAY 1000

int8_t i,count;
uint32_t status = 0;

unsigned int getDebouncedSwitchState (unsigned int);
unsigned int getSwitchState (void);

/* Get the debounced state of the switch. */
unsigned int
getDebouncedSwitchState (unsigned int previousState)
{
    unsigned int currentState = getSwitchState(); /* Get current state of the switch. */
    if (currentState == previousState) /* State is unchanged. */
        return previousState;

    /* Instantaneous state has changed. Wait for it to stabilize using
     * debouncing algorithm. The state has to remain unchanged for four
     * consecutive sampling periods. */
    unsigned int i = 0, j = 0;
    unsigned int nextState;

    while (j != 0x001E) {
        nextState = getSwitchState ();
        if (currentState == nextState) {
            j |= 0x0001;
            j = j << 1;
        }
        else
            j = 0;

        currentState = nextState;

        /* Delay. Needs to be tuned by programmer for the debounce
         * algorithm to work correctly. Usually switch specific. */
        for (i = DELAY; i > 0; i--);
    }

    return currentState;
}
unsigned int
getSwitchState (void)
{
    if (GPIO_getInputPinValue (GPIO_PORT_P1,GPIO_PIN1) == GPIO_INPUT_PIN_LOW)
        return SWITCH_PRESSED;
    else
        return SWITCH_RELEASED;
}


int
main (void)
{
    /* Stop Watchdog timer. */
    MAP_WDT_A_holdTimer ();

    /* Configure the output GPIO pins driving the LEDs. */
    GPIO_setAsOutputPin (GPIO_PORT_P2, GPIO_PIN0 | GPIO_PIN1);
    GPIO_setOutputLowOnPin (GPIO_PORT_P2, GPIO_PIN0 | GPIO_PIN1);

    /* Configure input GPIO pins, P1.1 for BUTTON1 and BUTTON2 P1.4. */
    GPIO_setAsInputPinWithPullUpResistor (GPIO_PORT_P1, GPIO_PIN1 | GPIO_PIN4);
    GPIO_interruptEdgeSelect (GPIO_PORT_P1, GPIO_PIN1 | GPIO_PIN4, GPIO_LOW_TO_HIGH_TRANSITION);
    GPIO_clearInterruptFlag (GPIO_PORT_P1, GPIO_PIN1 | GPIO_PIN4);
    GPIO_enableInterrupt (GPIO_PORT_P1, GPIO_PIN1 | GPIO_PIN4);
    Interrupt_enableInterrupt (INT_PORT1);
    Interrupt_enableMaster ();
    count = 0;

    while (1);
}

/* ISR to handle IRQs generated by pins in PORT1. */
void
PORT1_IRQHandler (void)
{
    uint16_t status = GPIO_getEnabledInterruptStatus (GPIO_PORT_P1);
    GPIO_clearInterruptFlag (GPIO_PORT_P1, status);

    /* Check for the correct pin that generated the interrupt. */
    if (status & GPIO_PIN1)
        count++;

    else if (status & GPIO_PIN4)
        count --;

    if (count > 0)
        GPIO_setOutputHighOnPin (GPIO_PORT_P2, GPIO_PIN1);
    else if (count <0 )
        GPIO_setOutputHighOnPin (GPIO_PORT_P2, GPIO_PIN0);
    else if (count == 0){
        GPIO_setOutputLowOnPin (GPIO_PORT_P2,GPIO_PIN1);
        GPIO_setOutputLowOnPin (GPIO_PORT_P2, GPIO_PIN0);}
        


    return;
}
